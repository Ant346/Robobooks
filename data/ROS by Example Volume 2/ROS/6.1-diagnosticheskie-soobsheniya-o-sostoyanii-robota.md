# 6.1 Диагностические сообщения о состоянии робота

Тип сообщения диагностического статуса \(**DiagnosticStatus**\) ROS позволяет нам представлять различные виды диагностической информации в общем формате. Чтобы просмотреть определение сообщения, выполните команду:

```text
$ rosmsg show diagnostic_msgs/DiagnosticStatus
```

```text
byte OK=0 byte 
WARN=1 byte 
ERROR=2 byte 
level string name 
string message 
string hardware_id 
diagnostic_msgs/KeyValue[] values 
    string key 
string value
```

Как мы видим выше, сообщение сначала перечисляет три общих уровня состояния: OK, WARN и ERROR. Поле level содержит текущее состояние самого устройства и будет иметь значение 0, 1 или 2, чтобы указать состояние OK, WARN или ERROR соответственно. Далее мы видим три строки ****для хранения имени компонента, произвольного сообщения и его hardware\_id. Остальная часть сообщения представляет собой массив пар «ключ-значение», которые могут хранить необработанные значения, возвращаемые аппаратным драйвером. Например, пара ключ=температура \(key=temperature\), value=31 будет означать, что температура устройства составляет 31℃

Примечание: для читателей, заглядывая наперёд, в ROS Indigo в **DiagnosticStatus** был добавлен новый статус **STALE**. Это означает, что сообщение будет иметь новую подпись MD5 и не будет совместимо с узлами, работающими под управлением ROS Indigo или более ранней версии. Поэтому не следует смешивать диагностические узлы или мониторы роботов, работающие на preIndigo и post-Indigo дистрибутивах.

Данный драйвер аппаратного обеспечения обычно публикует массив таких значений используя тип сообщения **DiagnosticArray**, который выглядит следующим образом:

```text
std_msgs/Header header 
diagnostic_msgs/DiagnosticStatus[] status
```

Как мы видим, это сообщение состоит из заголовков ROS  и массива диагностических сообщений **DiagnosticStatus**, по одному для каждого отслеживаемого компонента. Это станет яснее ниже, когда мы рассмотрим конкретный пример использования сервоприводов Dynamixel.

